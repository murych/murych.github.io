# Настраиваем Qt Creator для работы с Arduino

Итак, первый лидар на сервомашинке оглядел комнату, русский язык на дешевый I2C экранчик повыводился.
Хочется двигаться дальше, выжимать из 8-битного контроллера максимум возможностей, запустить на нем светомузыку, 3д принтер, умный дом.
Но ребята на форумах смеются, что это игрушки для детей, и даже среды нормальной для разработки нету.
Проблему игрушечности трогать не будем.
А вот настроить серьезную среду для работы, чтобы и подсветка, и подсказки, и документация -- это сюда.

> Дисклеймер: у платформы Arduino есть один серьезный недостаток, за который её очень любят ругать -- нет внутрисхемного отладчика из коробки.
> Мало кто из новоиспеченных DIY-щиков дополнительно докупает AVR Dragon или что-то в этом духе.
> Поэтому установка и настройка отладчика (хоть и потенциально возможна) в этом руководстве рассматриваться не будет.

## Шаг 0 -- подготовка окружения

Наверное, очевидно, что для актуальности данного гайда надо иметь какую-нибудь ардуину.
Лично у меня лежит UNO rev3, и исходить я буду из этого.

Для удобной работы с исходными текстами программ очень удобно использовать систему контроля версий (VCS).
Они бывают разными, самый лучший выбор сейчас -- Git.
Нужно потратить некоторое время на его изучение, но в будущем это принесет серьезный выигрыш в удобстве разработки.

Если сидишь на любом дистрибутиве на основе линукса, то скорее всего, гит уже установлен.
Но на всякий случай, в Fedora его установка делается вот так:

```
$ sudo dnf install -y git
```

## Шаг 1 -- тулчейн

Тулчейном называют набор инструментов, в который входит все необходимое для всего этапа сборки бинарника из исходников: препроцессинга, компиляции, линковки и т.д.
Также сюда относят приложения для загрузки бинарника в целевое устройство.

Так как в ардуинах в основном установленны микроконтроллеры Atmel AVR, нам нужен соответствующий тулчейн.
В линуксах (в федоре, во всяком случае) он устанавливается примерно вот так:

```
$ sudo dnf install -y avr-gcc avr-gcc-c++ avr-libc avrdude
```

После установки у нас станут доступны следующие инструменты:

- `avr-gcc` - компилятор (и все остальное) для C файлов;
- `avr-g++` - компилятор (и все остальное) для C++ файлов;
- `avrdude` - загрузчик бинарников,

а также еще несколько всего, но в основном понадобятся эти три.

Также скачиваем (пока не придумал альтернативы) саму платформу Arduino, чтобы воспользоваться библиотеками и конфигами для avrdude:

```
$ sudo dnf install -y arduino
```

## Шаг 2 -- выбор среды

Итак, _модным_ ребятам в 2019 году нужно:

- полный FOSS;
- кроссплатформенность;
- кастомизируемость.

Конечно, первым вариантом на ум приходит vim, но мы хотели сразу среду разработки, а не навороченный блокнот.
Есть три популярных варианта -- Eclipse, Code::Blocks и QtCreator.
Но Eclipse громоздок, тормознут и неудобен, C::B выглядит плохо и ограничен в поддержке различных платформ.
Остается QtCreator, для которого как раз в последние полгода активно развивается плагин для поддержки встраиваемых систем.

Итак, ставим QtCreator в систему, например, у меня Fedora:

```
$ sudo dnf install -y qt-creator
```

## Шаг 3 -- система сборки

Если хочется писать серьезный проект, чем писать все в один _скетч_, лучше разбивать код на отдельные блоки в виде связки файлов `*.cpp`/`*.h`.
Для того, чтобы не вызывать каждый раз компилятор с кучей опций и перечислений нужных файлов, напишем рецепт сборки.
Собирать будем с помощью [cmake]() -- идейным продолжателем утилиты GNU Make, но более навороченной.
Под нее есть много готовых рецептов, она понятная, к ней легко пишутся свои и читаются чужие дополнения.
Также в ней есть встроенная поддержка различных утилит, например, утилиты Doxygen для генерирования документации к проекту (подробнее об этом тут (пока в процессе)).

Устанавливаем:

```
$ sudo dnf install -y cmake
```

Далее, чтобы не писать самостоятельно поиск библиотек ардуиновского ядра, скачаем [готовые дополнения для ардуины под cmake](https://github.com/arduino-cmake/Arduino-CMake-NG).
Например у меня есть отдельная директория, в которой я храню репозитории, скачанные с гитхаба:

```
$ cd ~/dist/github
$ git clone https://github.com/arduino-cmake/Arduino-CMake-NG
```

Можем почитать описание проекта.
Запомним, что нам понадобится файл `Arduino-CMake-NG/cmake/Arduino-Toolchain.cmake`.
Он содержит в себе функции по поиску тулчейна, ардуиновской платформы и т.д.

## Шаг 4 -- настройка среды

1. Открываем QtCreator, заходим в меню _About_ -> _About Plugins_. Здесь мы включим поддержку встаиваемых систем, т.е. микроконтроллеров. В появившемся окне в разделе _Device Support_ находим _Bare Metal (Experimental)_, ставим галочку, перезапускаем студию.
2. Далее открываем меню _Tools_ -> _Options_ -> _Kits_. Здесь настраиваются различные тулчейны под различные платформы. Это позволяет в одной среде написать сразу программу для ардуины по сбору данных с датчиков, и программу для ПК по отображению этих данных
    - в разделе _Compilers_ нажимаем _Re-detect_. Скорее всего, QtCreator сам найдет компиляторы в системе
    - если этого не произошло, то добавляем их сами по кнопке _Add_ -> _GCC_
    - для компилятора C открываем `/usr/bin/avr-gcc` и называем, например, AVR GCC :ok_hand:
    - для компилятора C++ открываем `/usr/bin/avr-g++` и называем AVR G++
3. В меню _Kits_ создаем новый набор, назовем AVR
    - в поле _Device type_ выбираем _Bare Metal Device_
    - _Compiler C_ -- _AVR GCC_
    - _Compiler C++_ -- _AVR G++_
    - _Debugger_ -- None
    - _Qt Version_ -- None
    - _CMake Tool_ -- по умолчанию _System CMake at `/usr/bin/cmake`_, если нет -- настрой
    - _Cmake Generator_ -- нажать на _Change_:
        + _Generator_ -- _Unix Makefiles_
        + _Extra generator_ -- _CodeBlocks_
    - _CMake Configuration_ -- нажать на _Change_:
        + удаляем строчку про Qt
        + добавляем строчку с путем до ардуинного рецепта: `CMAKE_TOOLCHAIN_FILE:FILE=~/dist/github/Arduino-CMake-NG/cmake/Arduino-Toolchain.cmake`

Готово, теперь все проекты, для которых будет выбран этот набор/тулчейн, будут использовать одни и те же инструменты для сборки.

## Шаг 5 -- начинаем писать код

Ну, все готово, чтобы по классике помигать светодиодом.
Создадим где-нибудь директорию под наш "проект" и запузырим туда файл со взрослым расширением:

```bash
$ mkdir ~/Documents/arduino-cmake-blink/
$ cd ~/Documents/arduino-cmake-blink/
$ touch main.cpp main.h CMakeLists.txt
```

В QtCreator открываем _File_ -> _Open File or Project_, находим только что созданный `CMakeLists.txt`.
Файл загружается, но так как он пустой, проект сбоку тоже пустой, и никому это не нравится.
Но мы не сдаемся и пишем в файл следующее:

```cmake
cmake_minimum_required(VERSION 3.8.2)

project(arduino-cmake-blink LANGUAGES C CXX ASM)
set(CMAKE_CXX_STANDARD 11)

set(CMAKE_SYSTEM_NAME Generic)
set(CMAKE_SYSTEM_PROCESSOR avr)
set(CMAKE_CROSSCOMPILING 1)

arduino_cmake_project(${PROJECT_NAME} BOARD_NAME uno BOARD_CPU atmega328p)

set(SOURCES main.cpp)
set(HEADERS main.h)

add_arduino_executable(${PROJECT_NAME} ${SOURCES} ${HEADERS})
```

Рассмотрим подробнее:

- команда `cmake_minimum_required` фиксирует минимально необходимую версию cmake на определенном уровне. Это нужно в том числе для гарантии запуска проекта на разных системах;
- команда  `project` задает имя проекта, а также указывает, какие языки будут использоваться. Писать мы будем на С++ (который CXX), но внутри все равно присутствует как минимум ассемблер, так что накидываем по полной;
- далее задаем переменную `CMAKE_CXX_STANDART` -- стандарт C++11, который хорошо поддерживается компилятором и дает много различных фишек по сравнению с предыдущими стандартами языка;
- переменные `CMAKE_SYSTEM_NAME`, `CMAKE_SYSTEM_PROCESSOR` и `CMAKE_CROSSCOMPILING` говорят системе сборки о том, что мы будем заниматься процессом кросс-компиляции, следовательно, пробовать запустить скомпилированный бинарник на хост-системе не нужно;
- команда `arduino_cmake_project` декларирует проект уже для ардуины, задает название платы и контроллера на ней установленного (список можно посмотреть тут);
- прописываем файлы исходников (у нас их мало, поэтому можем поштучно);
- прописываем файлы заголовков;
- создаем цель компиляции -- бинарник с именем проекта, состоящий из файлов исходников и заголовков.

Далее нажимаем в меню _Build_ -> _Clear CMake configuration_ на случай, если успел создаться какой-то кэш сборки.
После этого там же нажимаем _Build_ -> _Rescan Project_ и наблюдаем за тем, как в боковой панели появляются файлы проекта.

Открываем там `main.cpp` и пишем туда хрестоматийный ардуинский блинк:

```c++
#include <Arduino.h>

#define PIN_LED 13

void setup() {
    pinMode(PIN_LED, OUTPUT);
}

void loop() {
    digitalWrite(PIN_LED, HIGH);
    delay(500);
    digitalWrite(PIN_LED, LOW);
    delay(500);
}
```

Нажимаем `Ctrl+B` или идем в меню _Build_ -> _Build Project_, смотрим на выхлоп компилятора.

Если ничего дополнительно не менялось, то в директории `Documents`, рядом с директорией проекта, должна появиться новая с названием типа `build-arduino-cmake-blink-ARM-Debug`.
В ней будут храниться результаты сборки проекта -- промежуточные файлы после работы препорцессора, результаты компиляции и линковки.
Но в первую очередь, в ней лежит готовый бинарник -- `arduino-cmake-blink.hex`.
Его-то нам и надо.

## Шаг 6 -- заливаем прошивку

Вообще, меньше всего проблем в работе с ардуинами возникает, если использовать оригинальные платы.
К ним всегда идут адекватные драйвера, а в линуксах они просто работают после подключения.

Во всяком случае, если подключить оригинальную Arduino Uno, то она должна занять порт `/dev/ttyACM0`.
Запоминаем.

В боковой панели QtCreator'а нажимаем на пиктограмму гаечного ключа (или `Ctrl+5`) и переходим в режим управления проектом.
Тут у нас можно включить / отключить тулчейн для проекта, а также настроить процесс сборки и запуска.
Нас интересует процесс запуска.

В секции _Build & Run_ в тулчейне AVR выбираем пункт _Run_.
На открывшемся экране в секции _Run Configuration_ нажимаем _Add_ -> _Custom Executable_ и прописываем следующие параметры:

- _Executable_: `/usr/bin/avrdude`
- _Command line arguments_: `-c arduino -p atmega328p -P "/dev/ttyACM0" -b 115200 -U flash:w:"%{CurrentProject:BuildPath}/%{CurrentProject:Name}.hex":i`

В аргументах для avrdude предлагаю разобраться самостоятельно с помощью дедукции, смекалочки и, если не поможет, документации.

Теперь подключаем ардуину к компу (если еще не).
Возвращаемся в редактор по пиктограмме карандаша (или `Ctrl+2`) и запускаем заливку прошивки на кнопке Play ниже или `Ctrl+R`.

Avrdude плюётся логами, и, в идеале, прошивка скачалась, вы великолепны!
